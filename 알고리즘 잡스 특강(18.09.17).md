## 알고리즘 잡스 특강

1. 비트연산자의 활용 방안
2. 문자열 응용 (多)
3. 해쉬
4. **시뮬레이션 (구현)**
   - 프렌즈 블록
5. **Basic Brute-Force(완전탐색)**
6. 정렬
   - 여러 라이브러리 활용해서 할 줄 알아야함.
   - 구조체에서 정렬
   - 2차원 정렬!
7. STL 활용 (**map, sort** 등)
8. 1차 - on-line Library 활용(반드시 출처 표기)



#### 카카오 코딩테스트 작년 기출

1. 비트연산자
2. 문자열, 구현
3. 해쉬, 구현
4. 문자열 처리, 정렬, 구현
5. 해쉬, 구현, 문자열 처리
6. 시뮬레이션, Basic brute Force
7. 문자열, 정렬, 구현, 완전탐색



- 구현능력은 일일이 대입하는게 아닌, 예외 처리와 적절한 초기화를 잘해야함.

- **알고리즘 시험에서 디버깅하는건 준비가 안됐다는것....** 차라리 print 해서 보기
- 모두 적어놓은 상태에서 구현하는 것이 좋은 습관.
- 극단적인 예제를 넣어보기. n = 최소, n = 최대 (경계에서 찾아보기)
- 입력 형식이 10만 이상 -> 시간복잡도 N^2 로 절대 풀 수 없는 문제 



#### (3번) 캐시 문제풀이

LRU : 사용한지 오래된 데이터 제거

Queue <- 제주, 판교, 서울, 뉴욕, LA 순서로 삽입

캐시크기 3 < 3개만 저장 가능

5 + 5 + 5 + 5(제주 제거하고 뉴욕) + 5(판교 제거하고 LA)



#### (4번) 셔틀버스

무조건 정시, 정시-1분전



#### (5번) 뉴스 클러스터링

무조건 두글자! B+ 이런건 버린다

```c++
count1["FR"]++; // 해쉬구조. (map 라이브러리)
count2["NC"]++;
```

교집합은 둘중에 개수가 작은 놈을 고르면 교집합!

min : 교집합을 구할 때 작은 것

max : 합집합을 구할 때 큰 것



#### (6번) 프렌즈4블록 : 전형적인 Brute Force 문제 (재귀함수X)

```C++
if (arr[i+1][j+1] == 1 && i + 1 < N); // 조회를 했기 때문에 런타임 에러 발생 가능
if (i + 1 < N) {
	if (arr[i+1][j+1]);
}
```

새로운 배열을 만들어서 사라지는 블록을 체크하면 된다 (+1)

그리고 마지막에 1 이상인 값들을 가져오면 된다.

밑에서부터 당기면 좋다. (아래에서 위로 반복 돌리기 -> 이중 for문 연습 필요)

위가 0이 아닐때까지 당기기.

예외처리(인덱스 오류)와 초기화(사용한 뒤에 저장했던 배열) 중요.



